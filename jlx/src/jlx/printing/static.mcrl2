%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Structure of state machines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	StateMachine = struct StateMachine(
		transitions: List(Transition),
		initialState: StateConfig,
		states: List(StateName),
		stateInfo: StateName -> StateInfo,
		initialValuation: ValueStorage
	);
	StateInfo = struct RootVertex ?is_root
		| SimpleState(parent: StateName, entryAction: Instructions, exitAction: Instructions) ?is_simple
		| CompositeState(parent: StateName, entryAction: Instructions, exitAction: Instructions) ?is_composite
		| JoinVertex(parent: StateName) ?is_join
		| JunctionVertex(parent: StateName) ?is_junction
		| ForkVertex(parent: StateName) ?is_fork
		| InitialState(parent: StateName) ?is_initial
		| FinalState(parent: StateName) ?is_final
		| ChoiceVertex(parent: StateName) ?is_choice;
	Event = struct none
		| ChangeEvent(get_expression: Instructions) ?is_change_event
		| TimeoutEvent ?is_timeout
		| SignalEvent(signal_name:VarName, params:List(VarValuePair)) ?is_signal_event
		| ChangeEventWithDataParams(get_expression: Instructions, params: List(VarValuePair)) ?is_change_event_with_data;
	Transition = struct Transition(
		source:StateName,
		trigger:Event,
		guard:Instructions,
		effect:Instructions,
		target:StateName,
		internal: Bool
	);
	% A state machine is 'in' a state configuration, which is a tree of states (including composite states and parallel regions):
	StateConfig = struct EmptyStateConfig
		| StateConfig(rootState:StateName, substates:List(StateConfig));


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASAL value types:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	Value = struct
		Value_Int(Int)
		| Value_Bool(Bool) %May represent a Pulse value as well
		| Value_Custom(Custom_Value)
		| Value_Pulse_Pack(params: List(VarValuePair)) ?is_pulse_pack
		| Value_Signal(signal_name:VarName, params: List(VarValuePair)) ?is_signal;

	Instruction = struct ASALA_PushLocalVar(VarName)
		| ASALA_SetLocalVar(VarName)
		| ASALA_SetGlobalVar(VarName) ?is_global_var_update
		| ASALA_Op1(ASALUnaryOp)
		| ASALA_Op2(ASALBinaryOp)
		| ASALA_Fct(FunctionName) ?is_function_call
		| ASALA_Jump(Int)
		| ASALA_JumpIfFalse(Int)
		| ASALA_PushValue(Value)
		| ASALA_PushGlobalVar(VarName) ?is_global_var_read
		| ASALA_Return
		| ASALA_Pop
	;
	Instructions = List(Instruction);

map
	ASALA_DefaultGuard: Instruction;
eqn
	ASALA_DefaultGuard = ASALA_PushValue(Value_Bool(true));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASAL operators:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	%Unary operators
	ASALUnaryOp = struct ASALUnaryOp_Plus
		| ASALUnaryOp_Minus
		| ASALUnaryOp_Negation
	;

	%Binary operators
	ASALBinaryOp = struct ASALBinaryOp_Add
		| ASALBinaryOp_Subtract
		| ASALBinaryOp_Mult
		| ASALBinaryOp_Div
		| ASALBinaryOp_Mod
		| ASALBinaryOp_Eq
		| ASALBinaryOp_Neq
		| ASALBinaryOp_Leq
		| ASALBinaryOp_Geq
		| ASALBinaryOp_Less
		| ASALBinaryOp_Greater
		| ASALBinaryOp_And
		| ASALBinaryOp_Or
		| ASALBinaryOp_Xor
	;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% How to apply standard ASAL operators:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
map
	applyUnaryOp: ASALUnaryOp # Value -> Value;
	applyBinaryOp: ASALBinaryOp # Value # Value -> Value;
	autocastToBool: Value -> Bool;
	autocastToVarType: CompName # VarName # Value -> Value;
var
	i, i1, i2: Int;
	b, b1, b2: Bool;
	v1, v2: Value;
eqn
	applyUnaryOp(ASALUnaryOp_Plus, Value_Int(i)) = Value_Int(i);
	applyUnaryOp(ASALUnaryOp_Minus, Value_Int(i)) = Value_Int(-i);
	applyUnaryOp(ASALUnaryOp_Negation, Value_Bool(b)) = Value_Bool(!b);
	applyBinaryOp(ASALBinaryOp_Add, Value_Int(i1), Value_Int(i2)) = Value_Int(i1 + i2);
	applyBinaryOp(ASALBinaryOp_Subtract, Value_Int(i1), Value_Int(i2)) = Value_Int(i1 - i2);
	applyBinaryOp(ASALBinaryOp_Mult, Value_Int(i1), Value_Int(i2)) = Value_Int(i1 * i2);
	(i1 > 0) -> applyBinaryOp(ASALBinaryOp_Mod, Value_Int(i1), Value_Int(i2)) = Value_Int(i2 mod Int2Pos(i1));
	applyBinaryOp(ASALBinaryOp_Eq, v1, v2) = Value_Bool(v1 == v2);
	applyBinaryOp(ASALBinaryOp_Neq, v1, v2) = Value_Bool(v1 != v2);
	applyBinaryOp(ASALBinaryOp_Leq, Value_Int(i1), Value_Int(i2)) = Value_Bool(i1 <= i2);
	applyBinaryOp(ASALBinaryOp_Geq, Value_Int(i1), Value_Int(i2)) = Value_Bool(i1 >= i2);
	applyBinaryOp(ASALBinaryOp_Less, Value_Int(i1), Value_Int(i2)) = Value_Bool(i1 < i2);
	applyBinaryOp(ASALBinaryOp_Greater, Value_Int(i1), Value_Int(i2)) = Value_Bool(i1 > i2);
	applyBinaryOp(ASALBinaryOp_And, Value_Bool(b1), Value_Bool(b2)) = Value_Bool(b1 && b2);
	applyBinaryOp(ASALBinaryOp_Or, Value_Bool(b1), Value_Bool(b2)) = Value_Bool(b1 || b2);
	applyBinaryOp(ASALBinaryOp_Xor, Value_Bool(b1), Value_Bool(b2)) = Value_Bool(!(b1 && b2) && (b1 || b2));


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ASAL instructions:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%ASAL function frame:
sort
	VarValuePair = struct VarValuePair(getVariable:VarName, getValue:Value);
	ExcFrame = struct EmptyExcFrame | ExcFrame(
		instructions: Instructions,
		numInstructions: Nat,
		instructionsPos: Nat, % Index of the next-to-be-executed ASALA instruction
		globalValuation: ValueStorage,
		localValuation: VarName -> Value,
		varUpdates: List(VarValuePair),
		stack: List(Value), % Used to do value computations
		subFrame: ExcFrame,
		isPaused: Bool
	);

map
	initializeExcFrame: Instructions#ValueStorage -> ExcFrame;
	unpauseExcFrame: ExcFrame -> ExcFrame;
	executeExcFrameCode: ExcFrame -> ExcFrame;
	executeInstruction: ExcFrame # Instruction -> ExcFrame;
	getInitialLocalVars: List(VarName)#List(Value)#(VarName -> Value) -> (VarName -> Value);
	popMultiple: List(Value) # Int -> List(Value);
	emptyMapping: VarName -> Value;
	checkPredicate: Instructions#ValueStorage -> Bool;
	checkPredicate: ExcFrame -> Bool;
	getVars: List(VarValuePair) -> List(VarName);
	setMultVars: List(VarValuePair)#ValueStorage -> ValueStorage;
	isFinished: ExcFrame -> Bool;

var
	c: Instructions;
	cp, diff, n, l: Nat;
	gvs: ValueStorage;
	lvs,m: VarName -> Value;
	s: List(Value);
	sf: ExcFrame;
	zzz: Bool;
	stackTop1: Value;
	stackTop2: Value;
	varName: VarName;
	op1: ASALUnaryOp;
	op2: ASALBinaryOp;
	fctName: FunctionName;
	v: Value;
	paramName: VarName;
	paramNames, l_var: List(VarName);
	u: List(VarValuePair);
	vv: VarValuePair;
	f: ExcFrame;
	lf: List(ExcFrame);
eqn
	isFinished(f) = instructionsPos(f) >= #instructions(f);
	getVars([]) = [];
	getVars(vv |> u) = getVariable(vv) |> getVars(u);
	setMultVars([], gvs) = gvs;
	setMultVars(vv |> u, gvs) = setMultVars(u,setValue(gvs,getVariable(vv),getValue(vv)));

	%Given a list of Instructions and a valuation of variables, construct a function frame that is ready for execution
	initializeExcFrame(c,gvs) = ExcFrame(c, #c, 0, gvs, emptyMapping, [], [], EmptyExcFrame, false);

	% Unpause function frames recursively.
	% Do this immediately before resuming paused code:
	unpauseExcFrame(EmptyExcFrame) = EmptyExcFrame;
	unpauseExcFrame(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, zzz)) =
		ExcFrame(c, l, cp, gvs, lvs, [], s, unpauseExcFrame(sf), false);

	(cp < l && !zzz) -> executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, EmptyExcFrame, zzz))
		= executeExcFrameCode(executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, EmptyExcFrame, zzz), c . cp));
	(cp >= l || zzz) -> executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, EmptyExcFrame, zzz))
	 	= ExcFrame(c, l, cp, gvs, lvs, u, s, EmptyExcFrame, zzz);

	(sf != EmptyExcFrame && instructionsPos(sf) < numInstructions(sf) && !isPaused(sf))
		-> executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, zzz))
		= executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, executeExcFrameCode(sf), zzz));

	(sf != EmptyExcFrame && isPaused(sf))
		-> executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, zzz))
		% Computed subframe is not done, so we keep it. We propagate the 'paused' state, the global valuation and var updates upwards:
		= ExcFrame(c, l, cp, globalValuation(sf), lvs, varUpdates(sf), s, sf, isPaused(sf));

	(sf != EmptyExcFrame && instructionsPos(sf) >= numInstructions(sf))
		-> executeExcFrameCode(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, zzz))
		% Computed subframe is done, so except for the stack we throw it out.
		% We propagate the 'paused' state, the global valuation and var updates upwards:
		= executeExcFrameCode(ExcFrame(c, l, cp + 1, globalValuation(sf), lvs, varUpdates(sf), s ++ stack(sf), EmptyExcFrame, isPaused(sf)));


	% Execute 1 ASALA instruction:
	(s != []) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_SetGlobalVar(varName)) =
		ExcFrame(c, l, cp + 1,
				setValue(gvs,varName,rhead(s)),
			lvs, u <| VarValuePair(varName, rhead(s)), s, sf, false);
	(s != []) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_SetLocalVar(varName)) =
		ExcFrame(c, l, cp + 1, gvs, lvs[varName -> rhead(s)], u, s, sf, false);
	(s != []) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Op1(op1)) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, rtail(s) <| applyUnaryOp(op1, rhead(s)), sf, false);
	(#s > 1) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Op2(op2)) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, rtail(rtail(s)) <| applyBinaryOp(op2, rhead(s), rhead(rtail(s))), sf, false);
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Fct(fctName)) =
		ExcFrame(c, l, cp, gvs, lvs, u, popMultiple(s, #getFunctionParams(fctName)),
				ExcFrame(getFunctionBodies(fctName), #getFunctionBodies(fctName), 0, gvs,
					getInitialLocalVars(getFunctionParams(fctName), s, emptyMapping), u, [], EmptyExcFrame, false), false);
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Jump(diff)) =
		ExcFrame(c, l, Int2Nat(cp + diff), gvs, lvs, u, s, sf, false);
	(s != []) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_JumpIfFalse(diff)) =
		if(rhead(s) == Value_Bool(true),
			ExcFrame(c, l, cp + 1, gvs, lvs, u, rtail(s), sf, false),
			ExcFrame(c, l, Int2Nat(cp + diff), gvs, lvs, u, rtail(s), sf, false));
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_PushValue(v)) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, s <| v, sf, false);
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_PushGlobalVar(varName)) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, s <| getValue(gvs,varName), sf, false);
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_PushLocalVar(varName)) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, s <| lvs(varName), sf, false);
	executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Return) =
		ExcFrame(c, l, l, gvs, lvs, u, s, sf, false);
	(s != []) -> executeInstruction(ExcFrame(c, l, cp, gvs, lvs, u, s, sf, false), ASALA_Pop) =
		ExcFrame(c, l, cp + 1, gvs, lvs, u, rtail(s), sf, false);

	% Assign parameter values to parameter names (helper function):
	(paramNames == [] || s== []) -> getInitialLocalVars(paramNames, s, m) = m;
	(#paramNames > 0 && s != []) -> getInitialLocalVars(paramNames, s, m) =
		getInitialLocalVars(rtail(paramNames), rtail(s), m[rhead(paramNames) -> rhead(s)]);

	% Pop a specified number of values from a stack (helper function):
	popMultiple([], n) = [];
	(n <= 0) -> popMultiple(s, n) = s;
	(n > 0 && s != []) -> popMultiple(s, n) = popMultiple(rtail(s), Int2Nat(n - 1));

	%To check a predicate, first initialize a function frame...
	checkPredicate(c, gvs) = checkPredicate(initializeExcFrame(c, gvs));
	%Execute the execution frame until finished...
	(instructionsPos(f) < #instructions(f)) -> checkPredicate(f) =
		checkPredicate(executeExcFrameCode(unpauseExcFrame(f)));
	%Guard is true if the top of the stack contains the value true
	(instructionsPos(f) == #instructions(f)) -> checkPredicate(f) =
		#stack(f) > 0 => head(stack(f)) == Value_Bool(true);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Basic operations states and state configurations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
map
	filterStateList: List(StateName)#(StateName -> Bool) -> List(StateName);
	getForks: StateMachine -> List(StateName);
	getJoins: StateMachine -> List(StateName);
	getJunctions: StateMachine -> List(StateName);
	getInitialStates: StateMachine -> List(StateName);
	getFinalStates: StateMachine -> List(StateName);
	getEntryActionState: StateMachine#StateName -> Instructions;
	getExitActionState: StateMachine#StateName -> Instructions;
	getAllStatesConfig: StateConfig -> Set(StateName);
	getAllStatesConfigList: List(StateConfig) -> Set(StateName);
	containsPseudoState: StateConfig#StateMachine -> Bool;
	maxDepth: StateConfig -> Int;
	maxDepthList: List(StateConfig) -> Int;
var
	s: StateName;
	ls: List(StateName);
	sc_list: List(StateConfig);
	sc, sc2: StateConfig;
	sm: StateMachine;
	filter: StateName -> Bool;
eqn
	filterStateList([], filter) = [];
	filterStateList(s |> ls, filter) = if(filter(s), [s], []) ++ filterStateList(ls, filter);
	getForks(sm) = filterStateList(states(sm), lambda x:StateName. is_fork(stateInfo(sm)(x)));
	getJunctions(sm) = filterStateList(states(sm), lambda x:StateName. is_junction(stateInfo(sm)(x)));
	getJoins(sm) = filterStateList(states(sm), lambda x:StateName. is_join(stateInfo(sm)(x)));
	getInitialStates(sm) = filterStateList(states(sm), lambda x:StateName. is_initial(stateInfo(sm)(x)));
	getFinalStates(sm) = filterStateList(states(sm), lambda x:StateName. is_final(stateInfo(sm)(x)));
	getEntryActionState(sm, s) = if(is_simple(stateInfo(sm)(s)) || is_composite(stateInfo(sm)(s)),
		entryAction(stateInfo(sm)(s)),
		[]);
	getExitActionState(sm, s) = if(is_simple(stateInfo(sm)(s)) || is_composite(stateInfo(sm)(s)),
		exitAction(stateInfo(sm)(s)),
		[]);
	getAllStatesConfig(StateConfig(s, sc_list)) = {s} + getAllStatesConfigList(sc_list);
	getAllStatesConfigList([]) = {};
	getAllStatesConfigList(sc |> sc_list) = getAllStatesConfig(sc) + getAllStatesConfigList(sc_list);
	containsPseudoState(sc,sm)  = exists v:StateName. v in getAllStatesConfig(sc) && (is_choice(stateInfo(sm)(v)) || is_join(stateInfo(sm)(v)) || is_fork(stateInfo(sm)(v))
		|| is_junction(stateInfo(sm)(v)) || is_initial(stateInfo(sm)(v)));

	%Computes the maximum depth from the root to the leafs.
	maxDepth(sc) = 1 + maxDepthList(substates(sc));
	maxDepthList([]) = 0;
	maxDepthList(sc |> sc_list) = max(maxDepth(sc),maxDepthList(sc_list));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Transformation from transitions to steps
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	Step = struct Step(
		source: StateConfig,
		trigger: Event,
		guard: List(Instructions),
		effect: ComposedBehavior,
		target: StateConfig,
		internal: Bool,
		arrowEnd: StateName
	);
map
	Steps: StateMachine -> List(Step);
	convertTransitionToStep: List(Transition)#StateMachine -> List(Step);
	addAncestors: StateConfig#StateMachine -> StateConfig;
	getIncomingSteps: List(Step)#StateName -> List(Step); %Only works for non-composite states (otherwise it could be a Step within a composite state)
	getOutgoingSteps: List(Step)#StateName -> List(Step); %Only works for non-composite states (otherwise it could be a Step within a composite state)
	getSourceConfigs: List(Step) -> List(StateConfig);
	getTargetConfigs: List(Step) -> List(StateConfig);
	combineStateConfigs: List(StateConfig) -> StateConfig;
	goOneDeeperStateConfigList: List(StateConfig) -> List(StateConfig);
	replaceStateWithStateConfig: StateConfig#StateName#StateConfig -> StateConfig;
	replaceStateWithStateConfigList: List(StateConfig)#StateName#StateConfig -> List(StateConfig);
	combineGuards: List(Step) -> List(Instructions);
	combineEffectsList: List(Step) -> List(ComposedBehavior);
	removeSteps: List(Step)#List(Step) -> List(Step);
	removeJoins: List(StateName)#List(Step) -> List(Step);
	removeForks: List(StateName)#List(Step) -> List(Step);
	updateGuard: Step#List(Instructions) -> Step;
	processInitialStatesSteps: StateMachine#List(Step) -> List(Step);
	processInitialStatesTarget: StateConfig#StateMachine -> StateConfig;
	processInitialStatesTargetList: List(StateConfig)#StateMachine -> List(StateConfig);
	addFinalStatesSteps: StateMachine#List(Step) -> List(Step);
	addFinalStatesSource: StateConfig#StateMachine -> StateConfig;
	addFinalStatesSourceList: List(StateConfig)#StateMachine -> List(StateConfig);
	getInitialStates: StateName#List(StateName)#StateMachine -> List(StateConfig);
	getFinalStates: StateName#List(StateName)#StateMachine -> List(StateConfig);
	removeJunctions: List(StateName)#List(Step) -> List(Step);
	computeStepsReplacingJunction: List(Step)#List(Step)#List(Step) -> List(Step);
var
	p:Transition;
	plist: List(Transition);
	tlist, tfilter,t_incoming,t_outgoing,t_iter: List(Step);
	sc,replacement: StateConfig;
	s,s2:StateName;
	slist:List(StateName);
	sclist: List(StateConfig);
	sc1, sc2: StateConfig;
	sm: StateMachine;
	g: List(Instructions);
	t,t2:Step;
eqn
	convertTransitionToStep([],sm) = [];
	convertTransitionToStep(p |> plist,sm) =
		[Step(
			addAncestors(StateConfig(source(p),[]),sm),
			if(is_timeout(trigger(p)), TimeoutEvent, trigger(p)),
			[guard(p)],
			InstructionsToComposedBehavior(effect(p)),
			addAncestors(StateConfig(target(p),[]),sm),
			internal(p),
			target(p))]
		++ convertTransitionToStep(plist,sm);
	addAncestors(sc,sm) =
		if(parent(stateInfo(sm)(rootState(sc))) == root,
			sc,
			addAncestors(
				StateConfig(parent(stateInfo(sm)(rootState(sc))),[sc]),
				sm));
	getIncomingSteps([], s) = [];
	getIncomingSteps(t |> tlist, s) =
		if(s in getAllStatesConfig(target(t)),
			[t],
			[])
		++ getIncomingSteps(tlist, s);
	getOutgoingSteps([], s) = [];
	getOutgoingSteps(t |> tlist, s) =
		if(s in getAllStatesConfig(source(t)),
			[t],
			[])
		++ getOutgoingSteps(tlist, s);
	getSourceConfigs([]) = [];
	getSourceConfigs(t |> tlist) = source(t) |> getSourceConfigs(tlist);
	getTargetConfigs([]) = [];
	getTargetConfigs(t |> tlist) = target(t) |> getTargetConfigs(tlist);
	replaceStateWithStateConfig(sc,s,replacement) =
		if(rootState(sc) == s,
			replacement,
			StateConfig(
				rootState(sc),
				replaceStateWithStateConfigList(substates(sc),s,replacement)));
	replaceStateWithStateConfigList([],s,replacement) = [];
	replaceStateWithStateConfigList(sc |> sclist, s, replacement) =
		replaceStateWithStateConfig(sc,s,replacement)
		|> replaceStateWithStateConfigList(sclist,s,replacement);
	combineStateConfigs(sc1 |> sc2 |> sclist) =
		if(rootState(sc1) == rootState(sc2)
				&& ((getAllStatesConfigList(substates(sc1)) - getAllStatesConfigList(substates(sc2))) == getAllStatesConfigList(substates(sc1))),
			StateConfig(
				rootState(sc1),
				goOneDeeperStateConfigList(sc1 |> sc2 |> sclist)),
			StateConfig(
				rootState(sc1),
				[combineStateConfigs(goOneDeeperStateConfigList(sc1 |> sc2 |> sclist))]));
	goOneDeeperStateConfigList([]) = [];
	goOneDeeperStateConfigList(sc |> sclist) = substates(sc) ++ goOneDeeperStateConfigList(sclist);
	removeSteps([],tfilter) = [];
	removeSteps(t |> tlist, tfilter) =
		if(t in tfilter,
			[],
			[t])
		++ removeSteps(tlist,tfilter);
	combineGuards([]) = [];
	combineGuards(t |> tlist) = guard(t) ++ combineGuards(tlist);
	combineEffectsList([]) = [];
	combineEffectsList(t |> tlist) = effect(t) |> combineEffectsList(tlist);
	removeJoins([], tlist) = tlist;
	removeJoins(s |> slist, tlist) =
		removeJoins(slist,
			removeSteps(tlist, incoming ++ outgoing) <| Step(
				combineStateConfigs(getSourceConfigs(incoming)),
				none,
				combineGuards(incoming ++ outgoing),
				[ParBehaviors(combineEffectsList(incoming))] ++ effect(head(outgoing)),
				target(head(outgoing)),
				false,
				root))
			whr incoming = getIncomingSteps(tlist,s), outgoing = getOutgoingSteps(tlist,s) end;
	removeForks([],tlist) = tlist;
	removeForks(s |> slist,tlist) =
		removeForks(slist,
			removeSteps(tlist, incoming ++ outgoing) <| Step(
				source(head(outgoing)),
				none,
				combineGuards(incoming ++ outgoing),
				effect(head(incoming)) ++ [ParBehaviors(combineEffectsList(outgoing))],
				combineStateConfigs(getTargetConfigs(outgoing)),
				false,
				root))
			whr incoming = getIncomingSteps(tlist,s), outgoing = getOutgoingSteps(tlist,s) end;
	updateGuard(t,g) = Step(
		source(t),
		trigger(t),
		g,
		effect(t),
		target(t),
		internal(t),
		arrowEnd(t));
	processInitialStatesSteps(sm,[]) = [];
	processInitialStatesSteps(sm,t |> tlist) =
		Step(
			source(t),
			trigger(t),
			guard(t),
			effect(t),
			processInitialStatesTarget(target(t),sm),
			internal(t),
			arrowEnd(t))
		|> processInitialStatesSteps(sm,tlist);
	addFinalStatesSteps(sm,[]) = [];
	addFinalStatesSteps(sm,t |> tlist) =
		if(trigger(t) == none,
			[t],
			[Step(
				if(trigger(t) == none,
					addFinalStatesSource(source(t),sm),
					source(t)),
				trigger(t),
				guard(t),
				effect(t),
				target(t),
				internal(t),
				arrowEnd(t))])
		++ addFinalStatesSteps(sm,tlist);
	processInitialStatesTarget(sc,sm) =
		if(is_composite(stateInfo(sm)(rootState(sc))) && #substates(sc) == 0,
			StateConfig(rootState(sc), getInitialStates(rootState(sc),getInitialStates(sm),sm)),
			StateConfig(rootState(sc), processInitialStatesTargetList(substates(sc),sm)));
	processInitialStatesTargetList([],sm) = [];
	processInitialStatesTargetList(sc |> sclist,sm) =
		processInitialStatesTarget(sc,sm) |> processInitialStatesTargetList(sclist,sm);
	addFinalStatesSource(sc,sm) =
		if(is_composite(stateInfo(sm)(rootState(sc))) && #substates(sc) == 0,
			StateConfig(rootState(sc), getFinalStates(rootState(sc),getFinalStates(sm),sm)),
			StateConfig(rootState(sc), addFinalStatesSourceList(substates(sc),sm)));
	addFinalStatesSourceList([],sm) = [];
	addFinalStatesSourceList(sc |> sclist,sm) = addFinalStatesSource(sc,sm) |> addFinalStatesSourceList(sclist,sm);
	getInitialStates(s, s2 |> slist,sm) = if(parent(stateInfo(sm)(s2)) == s, [StateConfig(s2,[])], []) ++ getInitialStates(s,slist,sm);
	getInitialStates(s, [], sm) = [];
	getFinalStates(s, s2 |> slist,sm) = if(parent(stateInfo(sm)(s2)) == s, [StateConfig(s2,[])], []) ++ getFinalStates(s,slist,sm);
	getFinalStates(s, [], sm) = [];
	removeJunctions([],tlist) = tlist;
	removeJunctions(s |> slist, tlist) =
		removeJunctions(slist,
			removeSteps(tlist,getIncomingSteps(tlist,s) ++ getOutgoingSteps(tlist,s))
				++ computeStepsReplacingJunction(
					getIncomingSteps(tlist,s),
					getOutgoingSteps(tlist,s),
					getOutgoingSteps(tlist,s)));
	computeStepsReplacingJunction([],t_outgoing,t_iter) = [];
	computeStepsReplacingJunction(t |> t_incoming,t_outgoing,[]) =
		computeStepsReplacingJunction(t_incoming,t_outgoing,t_outgoing);
	computeStepsReplacingJunction(t |> t_incoming, t_outgoing,t2 |> t_iter) =
		[Step(
			source(t),
			trigger(t),
			guard(t) ++ guard(t2),
			effect(t) ++ effect(t2),
			target(t2),
			false,
			arrowEnd(t2))]
		++ computeStepsReplacingJunction(t |> t_incoming,t_outgoing,t_iter);


		Steps(sm) =
			addFinalStatesSteps(sm,
				processInitialStatesSteps(sm,
					removeForks(getForks(sm),
						removeJoins(getJoins(sm),
							removeJunctions(getJunctions(sm),
								convertTransitionToStep(transitions(sm),sm))))));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Step selection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Determine which Steps are possible/enabled/survive priority:
% Possible: filter Steps to Steps that are possible from current state configuration
% Enabled: filter Steps to Steps where the guard is true and event matches
% Priority: more deeply nested Steps have priority over others, filter Steps to the ones with the highest priority
map
	matchState:StateConfig#StateConfig -> Bool;
	filterPossible: List(Step)#StateConfig#StateMachine -> List(Step);
	filterEnabled: List(Step)#List(Event)#ValueStorage -> List(Step);
	filterPriority: List(Step) -> List(Step);
	filterPriority: List(Step)#List(Step) -> List(Step);
	StepHasPriorityOver: Step#Step -> Bool;
var
	sc,sc2: StateConfig;
	tr,tr1,tr2: Step;
	trs, trs_to_process, all_trs, steps: List(Step);
	e:Event;
	e_list: List(Event);
	vars:ValueStorage;
	sm: StateMachine;
eqn
	%When sc is the current state config and sc2 the source of a Step then the Step is
	%enabled when sc2 is contained in sc. sc may containt additional children states or parallel regions.
	matchState(sc,sc2) = (getAllStatesConfig(sc2) - getAllStatesConfig(sc)) == {};
	filterPossible([], sc, sm) = [];
	filterPossible(tr |> trs, sc, sm) = filterPossible(trs,sc,sm)
		%matchState checks whether we are in a state config that allows the Step.
		%If the current state configuration contains a pseudo state then we will only allow Steps
		%that include pseudo states in the source (we are busy with a more complex Step)
		++ if(matchState(sc,source(tr)) && (containsPseudoState(sc,sm) => containsPseudoState(source(tr),sm)),
			[tr],
			[]);
	filterEnabled([],e_list,vars) = [];
	filterEnabled(tr |> trs,e_list,vars) =
		if(trigger(tr) in e_list && forall g:Instructions. g in guard(tr) => checkPredicate(g,vars),[tr],[])
		++ filterEnabled(trs,e_list,vars);

	%Steps stemming from states deeper in the hierarchy have priority.
	filterPriority(trs) = filterPriority(trs,trs);
	filterPriority(tr |> trs_to_process,all_trs) =
		if(forall t':Step. t' in all_trs => !StepHasPriorityOver(t',tr) || t' == tr,
			[tr],
			[])
		++ filterPriority(trs_to_process,all_trs);
	filterPriority([],all_trs) = [];
	StepHasPriorityOver(tr1,tr2) =
		getAllStatesConfig(source(tr2)) - getAllStatesConfig(source(tr1)) == {}
		&& getAllStatesConfig(source(tr1)) - getAllStatesConfig(source(tr2)) != {}
		&& maxDepth(source(tr1)) > maxDepth(source(tr2));

% SMs can make multi-Steps, execute several Steps from parallel regions in one run to completion
% Here we compute, given a set of Steps, all possible combinations thate are conflict free.
% Conflict free means that no two Steps exit the same state.
map
	multistepPossibilities: List(Step) -> List(List(Step));
	multistepPossibilities: List(Step)#List(Step)#List(Step)#Bool -> List(List(Step));
	computeIfConflict: Step#Step -> Bool;
	List2FSet: List(Step) -> FSet(Step);
var
	trs,trs1,trs2,trs_to_process,all_trs,candidates,selected: List(Step);
	tr,tr1,tr2: Step;
	added: Bool;
eqn
	multistepPossibilities([]) = [];
	multistepPossibilities(tr |> trs) = multistepPossibilities(tr|> trs,tr|> trs,[],false);
	(forall t:Step. t in selected => !computeIfConflict(tr,t)) -> multistepPossibilities(tr |> trs,all_trs,selected,added) =
		multistepPossibilities(all_trs,all_trs,selected <| tr,false) ++ multistepPossibilities(trs,all_trs,selected,true);
	(exists t:Step. t in selected && computeIfConflict(tr,t)) -> multistepPossibilities(tr |> trs,all_trs,selected,added) =
		multistepPossibilities(trs,all_trs,selected,added);
	multistepPossibilities([],all_trs,selected,added) = if(added,[],[selected]);
	computeIfConflict(tr1,tr2) =
		(getAllStatesConfig(source(tr2)) - getExitedStates(source(tr1),target(tr1),tr1) != getAllStatesConfig(source(tr2)))
		|| (getAllStatesConfig(source(tr1)) - getExitedStates(source(tr2),target(tr2),tr2) != getAllStatesConfig(source(tr1)))
		|| !(is_change_event(trigger(tr1)) && trigger(tr1) == trigger(tr2));
	List2FSet([]) = {};
	List2FSet(tr |> trs) = {tr} + List2FSet(trs);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Next state computation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
map
	computeNextState: StateConfig#Step -> StateConfig;
	computeNextState: StateConfig#StateConfig#StateConfig#Set(StateName) -> StateConfig;
	computeNextStateSubstates: StateConfig#StateConfig#List(StateConfig)#Set(StateName) -> List(StateConfig);
	findSubstates: StateName#List(StateConfig) -> List(StateConfig);
	findUnaffectedRegions: List(StateConfig)#List(StateConfig)#Set(StateName) -> List(StateConfig);
	sortSubstates: List(StateConfig) -> List(StateConfig);
	removeStateConfig: List(StateConfig)#StateConfig -> List(StateConfig);
	findMinimum: List(StateConfig)#StateConfig#Nat -> StateConfig;
var
	s1, target_state: StateName;
	sc1,sc2,cur,source_sc,target_sc:StateConfig;
	tr: Step;
	sclist, sclist1, sclist2, source_substate_list, target_substate_list, cur_substate_list: List(StateConfig);
	ordering: List(StateName);
	exited: Set(StateName);
	n: Nat;
eqn
	computeNextState(cur,tr) = computeNextState(
		cur,
		source(tr),
		target(tr),
		%if the Step is a selfloop, compute exited states
		if(arrowEnd(tr) in getAllStatesConfig(source(tr)),
			getAllStatesConfigList(findSubstates(arrowEnd(tr),[cur])),
			{}));
	%The basis of the next state is the target state configuration.
	%We add parallel regions that are not directly present in the target state configuration.
	computeNextState(cur,source_sc,target_sc,exited) =
		StateConfig(
			rootState(target_sc),
			sortSubstates(computeNextStateSubstates(cur,source_sc,substates(target_sc),exited)
				++ if(#findSubstates(rootState(target_sc),[source_sc]) > 0,
					findUnaffectedRegions(
						findSubstates(rootState(target_sc),[source_sc]),
						findSubstates(rootState(target_sc),[cur]),
						exited),
					[]))
		);

	%Recurse on all substates
	computeNextStateSubstates(cur,source_sc,sc1 |> target_substate_list,exited) =
		[computeNextState(cur,source_sc,sc1,exited)]
		++ computeNextStateSubstates(cur,source_sc,target_substate_list,exited);
	computeNextStateSubstates(cur,source_sc,[],exited) = [];

	%Search through state configuration for target_state, return all its substates.
	findSubstates(target_state,sc1 |> sclist) =
		if(rootState(sc1) == target_state,
			substates(sc1), %Found target_state, return its children
			%Not found. By adding substates to sclist we keep recursively searching downwards.
			findSubstates(target_state,sclist ++ substates(sc1)));
	findSubstates(target_state,[]) = [];

	%Find parallel regions that were not affected by a Steps
	%sc1 is an unaffected region of the current state config if it not part of the source state config
	%of the Step and it is not exited in a selfloop.
	findUnaffectedRegions(source_substate_list,sc1 |> cur_substate_list,exited) =
		if(rootState(sc1) in getAllStatesConfigList(source_substate_list) || rootState(sc1) in exited,
			[],
			[sc1])
		++ findUnaffectedRegions(source_substate_list,cur_substate_list,exited);
	findUnaffectedRegions(source_substate_list,[],exited) = [];

	(#sclist < 2) -> sortSubstates(sclist) = sclist;
	(#sclist >= 1) -> sortSubstates(sc1 |> sclist) =
		minElement |> sortSubstates(removeStateConfig(sc1 |> sclist, minElement)) whr minElement = findMinimum(sclist,sc1,stateIndex(rootState(sc1))) end;
	removeStateConfig([], sc1) = [];
	removeStateConfig(sc1 |> sclist, sc2) = if(sc1 == sc2, [], [sc1]) ++ removeStateConfig(sclist,sc2);
	findMinimum([],sc1,n) = sc1;
	(stateIndex(rootState(sc1)) < n) -> findMinimum(sc1 |> sclist, sc2, n) = findMinimum(sclist, sc1, stateIndex(rootState(sc1)));
	(stateIndex(rootState(sc1)) >= n) -> findMinimum(sc1 |> sclist, sc2, n) = findMinimum(sclist, sc2, n);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Behaviour selection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
map
	getExitedStates: StateConfig#StateConfig#Step -> Set(StateName);
	getEnteredStates: StateConfig#StateConfig#Step -> Set(StateName);
	determineBehaviourStep: StateMachine#Step#StateConfig -> ComposedBehavior;
	getEntryActions: StateMachine#StateConfig#Step -> ComposedBehavior;
	getExitActions: StateMachine#StateConfig#Step -> ComposedBehavior;
	determineOrderEntryBehavior: StateMachine#List(StateConfig)#Set(StateName)#List(StateConfig)#List(ComposedBehavior) -> ComposedBehavior;
	determineOrderExitBehavior: StateMachine#List(StateConfig)#Set(StateName)#List(StateConfig)#List(ComposedBehavior) -> ComposedBehavior;
	InstructionsToComposedBehavior: Instructions -> ComposedBehavior;
var
	sm: StateMachine;
	sc1,sc2,cur,target_sc: StateConfig;
	tr: Step;
	cur_level,next_level: List(StateConfig);
	entry_set,exit_set: Set(StateName);
	behavior_set: List(ComposedBehavior);
	par_comp,cb: List(ComposedBehavior);
	i: Instruction;
	instr: Instructions;
eqn
	%Computes the entered/exited states from a Step. sc is the state config before the Step
	%sc2 is the state config after the Step. In general the change in state config shows which
	%states are entered and exited. However, in the case of a self loop states may be entered and getExitedStates
	%without changing the state config. We detect that case by looking at which state the arrow points.
	getExitedStates(sc1,sc2,tr) = getAllStatesConfig(sc1) - getAllStatesConfig(sc2)
		+ if(arrowEnd(tr) in getAllStatesConfig(sc1),
				{arrowEnd(tr)} + getAllStatesConfigList(findSubstates(arrowEnd(tr),[sc1])),
				{});
	getEnteredStates(sc1,sc2,tr) = getAllStatesConfig(sc2) - getAllStatesConfig(sc1)
		+ if(arrowEnd(tr) in getAllStatesConfig(sc1),
				{arrowEnd(tr)} + getAllStatesConfigList(findSubstates(arrowEnd(tr),[sc2])),
				{});

	%For non internal Steps we first perform exit actions, then the effect of the Step and finally entry actions.
	%removeEmptyPar removes branches of parallel behavior that do not have any behavior.
	%getEntryActions and getExitActions may deliver such empty branches.
	(!internal(tr)) -> determineBehaviourStep(sm,tr,cur) =
		removeEmptyPar(getExitActions(sm,cur,tr)
		++ effect(tr)
		++ getEntryActions(sm,cur,tr));
	%If it is an internal Step we do not perform entry and exit actions.
	internal(tr) -> determineBehaviourStep(sm,tr,cur) = removeEmptyPar(effect(tr));

	InstructionsToComposedBehavior([]) = [];
	InstructionsToComposedBehavior(i |> instr) = Instruction(i) |> InstructionsToComposedBehavior(instr);

	%determineOrderEntryBehavior actually computes in what order what entry actions must be performed.
	getEntryActions(sm,cur,tr) =
		determineOrderEntryBehavior(
			sm,
			[computeNextState(cur,tr)],
			getEnteredStates(cur,computeNextState(cur,tr),tr),
			[],
			[]);
	%Entry behavior is performed outside in, first the entry behavior of the top level states are performed.
	%If there are still states to be evaluated at the current level of the hierarchy we apply this rule.
	determineOrderEntryBehavior(sm,sc1 |> cur_level,entry_set,next_level,behavior_set) =
		determineOrderEntryBehavior(
			sm,
			cur_level,
			entry_set,
			next_level ++ substates(sc1), %Add substates to next_level which will be dealt with later
			%If the state under configuration is actually entered we add its entry action behavior to behavior_set.
			%behavior_set contains all the parallel entry actions of the current level.
			behavior_set ++ if(rootState(sc1) in entry_set, [InstructionsToComposedBehavior(getEntryActionState(sm,rootState(sc1)))],[]));
	%If the current level is finished and there is still a next level to evaluate we apply this rule.
	determineOrderEntryBehavior(sm,[],entry_set,sc1 |> next_level, behavior_set) =
		%Behavior of current level is determined, add it to result.
		%Dependending on how many parallel entry actions we have discovered on this level we either
		%add the empty list, just the sequential entry action of one state or a ParBehaviors
		if(#behavior_set == 0,[],if(#behavior_set == 1, head(behavior_set), [ParBehaviors(behavior_set)]))
		%Recurse to next level
		++ determineOrderEntryBehavior(
			sm,
			sc1 |> next_level,
			entry_set,
			[],
			[]);
	%If the current level is finished and there is no next level to evaluate we simply return the behavior of behavior_set
	determineOrderEntryBehavior(sm,[],entry_set,[],behavior_set) =
		%Dependending on how many parallel entry actions we have discovered on this level we either
		%add the empty list, just the sequential entry action of one state or a ParBehaviors
		if(#behavior_set == 0,[],if(#behavior_set == 1, head(behavior_set), [ParBehaviors(behavior_set)]));

	%determineOrderExitBehavior actually computes in what order what entry actions must be performed.
	getExitActions(sm,cur,tr) =
		determineOrderExitBehavior(
			sm,
			[cur],
			getExitedStates(cur,computeNextState(cur,tr),tr),
			[],
			[]);
	%Exit behavior is performed inside out, first the exit behavior of the bottom level states are performed.
	%If there are still states to be evaluated at the current level of the hierarchy we apply this rule.
	determineOrderExitBehavior(sm,sc1 |> cur_level,exit_set,next_level,behavior_set) =
		determineOrderExitBehavior(
			sm,
			cur_level,
			exit_set,
			next_level ++ substates(sc1), %Add substates to next_level which will be dealt with later
			%If the state under configuration is actually entered we add its exit action behavior to behavior_set.
			%behavior_set contains all the parallel exit actions of the current level.
			behavior_set ++ if(rootState(sc1) in exit_set,[InstructionsToComposedBehavior(getExitActionState(sm,rootState(sc1)))],[]));
	%If the current level is finished and there is still a next level to evaluate we apply this rule.
	determineOrderExitBehavior(sm,[],exit_set,sc1 |> next_level, behavior_set) =
		%Recurse to next level
		determineOrderExitBehavior(sm,sc1 |> next_level,exit_set,[],[])
		%Behavior of current level is determined, add it to result.
		%Dependending on how many parallel exit actions we have discovered on this level we either
		%add the empty list, just the sequential entry action of one state or a ParBehaviors
		++ if(#behavior_set == 0,[],if(#behavior_set == 1, head(behavior_set), [ParBehaviors(behavior_set)]));
	%If the current level is finished and there is no next level to evaluate we simply return the behavior of behavior_set
	determineOrderExitBehavior(sm,[],exit_set,[],behavior_set) =
		%Dependending on how many parallel exit actions we have discovered on this level we either
		%add the empty list, just the sequential entry action of one state or a ParBehaviors
		if(#behavior_set == 0,[],if(#behavior_set == 1, head(behavior_set), [ParBehaviors(behavior_set)]));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Behaviour execution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	%Composed behavior:
	% It may happen that a Step consists several behaviors that must be executed in parallel (exit behavior of parllel regions for example)
	ComposedBehavior = List(InstructionOrPar);
	InstructionOrPar = struct Instruction(getInstruction:Instruction) ?is_instruction
		| ParBehaviors(parBehaviors:List(ComposedBehavior)) ?is_par;

	ExecutionOption = struct ExecutionOption(getCodeToExecute:Instructions, getRemainingBehavior:ComposedBehavior);
map
	computeExecutionOptions: ComposedBehavior -> List(ExecutionOption);
	computeExecutionOptionsPar: ComposedBehavior#List(ComposedBehavior)#List(ComposedBehavior)#List(ExecutionOption) -> List(ExecutionOption);
	computeExecutionOptionsSeq: ComposedBehavior#Instructions -> List(ExecutionOption);
	removeEmptyPar: ComposedBehavior -> ComposedBehavior;
	removeEmptyParList: List(ComposedBehavior) -> List(ComposedBehavior);
var
	c,c2,p:ComposedBehavior;
	par1,par2: List(ComposedBehavior);
	i:InstructionOrPar;
	instr:Instructions;
	e: ExecutionOption;
	l1, l2, l3: List(ExecutionOption);
eqn
	%Given a ComposedBehavior we want to compute all execution options (sequences of ASAL executions).
	computeExecutionOptions([]) = [];
	is_instruction(i) -> computeExecutionOptions(i |> c) = computeExecutionOptionsSeq(c, [getInstruction(i)]);
	is_par(i) -> computeExecutionOptions(i |> c) = computeExecutionOptionsPar(c, parBehaviors(i), [], []);

	%For ParBehaviors we let one of the parallel branches execute a sequence of instructions
	computeExecutionOptionsPar(c, par1, par2, e |> l1) =
		computeExecutionOptionsPar(c, par1, par2, l1)
		<| ExecutionOption(
			getCodeToExecute(e),
			removeEmptyPar(ParBehaviors(par1 ++ par2 <| getRemainingBehavior(e)) |> c)
		);
	computeExecutionOptionsPar(c, [], par2, []) = [];
	computeExecutionOptionsPar(c, p |> par1, par2, []) =
		computeExecutionOptionsPar(c, par1, p |> par2, [])
		++ computeExecutionOptionsPar(c, [], par1 ++ par2, computeExecutionOptions(p));

	%In the case of sequential instructions we can execute until we hit a ParBehaviors
	%or until there is no behavior left.
	computeExecutionOptionsSeq([], instr) = [ExecutionOption(instr,[])];
	is_instruction(i) -> computeExecutionOptionsSeq(i |> c, instr) =
		computeExecutionOptionsSeq(c, instr ++ [getInstruction(i)]);
	is_par(i) -> computeExecutionOptionsSeq(i |> c, instr) = [ExecutionOption(instr,i |> c)];

	%After executing code we might end with terms such as ParBehaviors([[]]). We want to remove these
	%as they don't offer any execution options. computeExecutionOptions assumes there is something to
	%execute in a ParBehaviors term.
	removeEmptyPar([]) = [];
	is_instruction(i) -> removeEmptyPar(i |> c) = i |> removeEmptyPar(c);
	is_par(i) -> removeEmptyPar(i |> c) =
		if(#removeEmptyParList(parBehaviors(i)) == 0,
			removeEmptyPar(c),
			ParBehaviors(removeEmptyParList(parBehaviors(i))) |> removeEmptyPar(c));
	removeEmptyParList([]) = [];
	removeEmptyParList(c |> par1) = if(#c == 0, removeEmptyParList(par1), c |> removeEmptyParList(par1));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Change event derivation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	Monitor = struct Monitor(getMonitorExpression:Instructions,getMonitorValuation:Bool);
map
	updateMonitors: List(Monitor)#ValueStorage -> List(Monitor);
	deriveChangeEvents: List(Monitor)#ValueStorage -> List(Event);
	deriveChangeEventsMultUpdates: List(Monitor)#ValueStorage#List(VarValuePair) -> List(Event);
	deriveMonitorsSM: StateMachine -> List(Monitor);
	deriveMonitors: List(Transition)#List(Monitor) -> List(Monitor);
var
	u: VarValuePair;
	updates: List(VarValuePair);
	monitors, updated: List(Monitor);
	mon: Monitor;
	derived_events: List(Event);
	vars: ValueStorage;
	sm: StateMachine;
	tr: Transition;
	trs: List(Transition);
	comp: CompName;
eqn
	updateMonitors(mon |> monitors,vars) = Monitor(getMonitorExpression(mon),
		checkPredicate(getMonitorExpression(mon),vars)) |> updateMonitors(monitors,vars);
	updateMonitors([],vars) = [];
	deriveChangeEvents(mon |> monitors,vars) =
		if(checkPredicate(getMonitorExpression(mon),vars) && !getMonitorValuation(mon),
			[ChangeEvent(getMonitorExpression(mon))],
			[]
		) ++ deriveChangeEvents(monitors,vars);
	deriveChangeEvents([],vars) = [];
	deriveChangeEventsMultUpdates(monitors, vars, []) = [];
	deriveChangeEventsMultUpdates(monitors, vars, u |> updates) =
		deriveChangeEvents(monitors,setValue(vars,getVariable(u),getValue(u)))
		++ deriveChangeEventsMultUpdates(
			updateMonitors(monitors,setValue(vars,getVariable(u),getValue(u))),
			setValue(vars,getVariable(u),getValue(u)),
			updates
		);
	deriveMonitorsSM(sm) = deriveMonitors(transitions(sm),[]);
	deriveMonitors([], monitors) = monitors;
	deriveMonitors(tr |> trs, monitors) = if(is_change_event(trigger(tr)) && !(Monitor(get_expression(trigger(tr)),false) in monitors),
		deriveMonitors(trs, monitors <| Monitor(get_expression(trigger(tr)),false)),
		deriveMonitors(trs,monitors));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%SysML specifc data structures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort
	Component = struct Component(
		name: CompName,
		SM: StateMachine,
		inPorts: List(VarName),
		outPorts: List(VarName),
		pulsePorts: List(VarName),
		dataParamPorts: List(VarName),
		paramsPerPulsePort: VarName -> List(VarName),
		synchronousPorts: List(VarName),
		functions: List(FunctionName)
	);
	CompPortPair = struct CompPortPair(getComp: CompName, getPort: VarName);
	Channel = struct Channel(sender: CompPortPair, receivers: List(CompPortPair));
	VarValuePair = struct VarValuePair(getVariable:VarName, getValue:Value);
map
	distillPortUpdates: List(VarValuePair)#Component#ValueStorage -> List(VarValuePair);
	addVarValuePairs: List(Event)#List(VarValuePair) -> List(Event);
	addParamPorts: Component#VarName#List(VarName)#ValueStorage#List(VarValuePair) -> VarValuePair;
var
	vv: VarValuePair;
	v,p: VarName;
	par_names: List(VarName);
	u, pars: List(VarValuePair);
	c: Component;
	e: Event;
	el: List(Event);
	gvs: ValueStorage;
eqn
	%Filter out updates to state machine variables to get updates of ports
	distillPortUpdates([],c,gvs) = [];
	distillPortUpdates(vv |> u, c, gvs) =
		if(getVariable(vv) in outPorts(c) && ((USE_PULSE_PACKS => !(getVariable(vv) in dataParamPorts(c))) && !(getVariable(vv) in pulsePorts(c) && getValue(vv) == Value_Bool(false))),
			[if(getVariable(vv) in pulsePorts(c) && USE_PULSE_PACKS,
				addParamPorts(c,getVariable(vv),paramsPerPulsePort(c)(getVariable(vv)),gvs,[]),
				vv)],
			[])
		++ distillPortUpdates(u, c, setValue(gvs,getVariable(vv),getValue(vv)));
	addVarValuePairs([], u) = [];
	addVarValuePairs(e |> el, u) = ChangeEventWithDataParams(get_expression(e),u) |> addVarValuePairs(el,u);
	addParamPorts(c,v,[],gvs,pars) = VarValuePair(v,Value_Pulse_Pack(pars));
	addParamPorts(c,v,p |> par_names,gvs,pars) = addParamPorts(c,v,par_names,gvs, pars <| VarValuePair(getConnectedDataParameterPort(name(c))(p),getValue(gvs,p)));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%State machine process definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
act
	sendComp,receiveI,send: CompPortPair#Value;
	sendI,receiveComp,receive: CompPortPair#Value;
	discardEvent: CompName#Event;
	selectMultiStep: CompName#Event#StateConfig;
	executeBehaviour: CompName;
	executeStep: CompName#StateConfig;
	inState: CompName#StateName;
	inEventPool: CompName#Event;
	eventPoolFull;
	resetVariables: CompName;
	varVal: CompName#VarName#Value;
	signalQueueLength, recQueueLength, checkQueueLength: CompName#Nat;

proc
	StateMachineInit(id:CompName, comp:Component) = StateMachine(
		id,
		comp,
		Steps(SM(comp)),
		initialState(SM(comp)),
		[],
		updateMonitors(deriveMonitorsSM(SM(comp)),initialValuation(SM(comp))),
		initialValuation(SM(comp)),
		[],
		[],
		EmptyExcFrame,
		[],
		[],
		[]
	);

	%Main process definition of components, it simulates a UML/SysML state machine
	StateMachine(
			id:CompName,
			comp:Component,
			steps: List(Step),
			sc:StateConfig, %SM is 'in' a hierarchy of states, possibly containg parallel regions
			eq: List(Event), %Events, stemming from for example 'when' statements are stored here until dispatch
			mon: List(Monitor), %For each expression inside a 'when' statement a monitor is needed to check when the valuation goes from false to true
			vars: ValueStorage, %Current value of variables, which are both proper variables as well as ports
			ms: List(Step), %In the case of parallel regions a multi-step of multiple transitions may be selected, which are stored in this variable
			behav: ComposedBehavior, %Stores behaviour to be executed for ongoing transition, may contain parallel behaviours
			exc: ExcFrame, %Function frame of instructions that are being executed, stores a paused execution
			mq: List(VarValuePair), %When during the execution of a function frame multiple ports are updates, the updates are temporarily stored here
			head_mq: List(VarValuePair),
			reset: List(VarName) %Inidicates that some values still need to be reset to their initial value
			) =
		(ADD_inState_SELFLOOPS) -> sum s:StateName. ((!ADD_ALL_inState_SELFLOOPS => s in ALLOWED_STATES_inState_SELFLOOPS)
			&& s in states(SM(comp)) && s in getAllStatesConfig(sc)) -> inState(id,s).StateMachine()
		+ (ADD_inEventPool_SELFLOOPS) -> sum e:Event. ((!ADD_ALL_inEventPool_SELFLOOPS => e in ALLOWED_EVENTS_inEventPool_SELFLOOPS)
			&& e in eq) -> inEventPool(id,e).StateMachine()
		+ (ADD_ABSTRACT_inEventPool_SELFLOOPS && #eq >= EVENT_QUEUE_BOUND) -> eventPoolFull.StateMachine()
		+ (ADD_varVal_SELFLOOPS) -> sum p:VarName . ((!ADD_ALL_varVal_SELFLOOPS => p in ALLOWED_VARS_varVal_SELFLOOPS)
			&& p in inPorts(comp)) -> varVal(id,p,getValue(vars,p)).StateMachine()
		+ signalQueueLength(id,if(#ms == 0 && #behav == 0 && exc == EmptyExcFrame && !containsPseudoState(sc,SM(comp)) && #head_mq == 0 && #reset == 0, #eq, #eq + 1)).StateMachine()
		%Receive messages on ports from other components, message queue is bound to prohibit infinite state space
		+ (#eq < EVENT_QUEUE_BOUND) -> sum v:Value,p:VarName.
			(v in possibleValues(id,p)
			&& ((USE_SYNCHRONOUS_PORTS && p in synchronousPorts(comp))
				=> (#ms == 0 && #behav == 0 && exc == EmptyExcFrame && !containsPseudoState(sc,SM(comp)) && #head_mq == 0 && #reset == 0)))
			-> signalQueueLength(id,if(#ms == 0 && #behav == 0 && exc == EmptyExcFrame && !containsPseudoState(sc,SM(comp)) && #head_mq == 0 && #reset == 0, #eq, #eq + 1))
			|receiveComp(CompPortPair(id,p),v).StateMachine(
				vars = if(p in pulsePorts(comp), vars, setValue(vars,p,v)),
				eq = eq ++
					if(is_pulse_pack(v),addVarValuePairs(deriveChangeEvents(mon,setMultVars(params(v),setValue(vars,p,Value_Bool(true)))),params(v)),[])
					++ if(!is_pulse_pack(v) && !is_signal(v),deriveChangeEvents(mon,setValue(vars,p,v)),[]) %Derive events from changed variable
					++ if(is_signal(v),[SignalEvent(signal_name(v), params(v))],[])
				%)
				,
				mon = if(p in pulsePorts(comp), mon, updateMonitors(mon,setValue(vars,p,v))))
		+ (#eq < EVENT_QUEUE_BOUND) -> sum v:Value,p:VarName.
			(v in possibleValues(id,p)
			&& ((USE_SYNCHRONOUS_PORTS && p in synchronousPorts(comp))
				=> (#ms == 0 && #behav == 0 && exc == EmptyExcFrame && !containsPseudoState(sc,SM(comp)) && #head_mq == 0 && #reset == 0)))
			-> receiveComp(CompPortPair(id,p),v).StateMachine(
				vars = if(p in pulsePorts(comp), vars, setValue(vars,p,v)),
				eq = eq ++
					if(is_pulse_pack(v),addVarValuePairs(deriveChangeEvents(mon,setMultVars(params(v),setValue(vars,p,Value_Bool(true)))),params(v)),[])
					++ if(!is_pulse_pack(v) && !is_signal(v),deriveChangeEvents(mon,setValue(vars,p,v)),[]) %Derive events from changed variable
					++ if(is_signal(v),[SignalEvent(signal_name(v), params(v))],[])
				%)
				,
				mon = if(p in pulsePorts(comp), mon, updateMonitors(mon,setValue(vars,p,v))))
		%if no Step is enabled by an event then it can be discarded
		+ (#ms == 0 && #behav == 0 && exc == EmptyExcFrame && #eq != 0 && !containsPseudoState(sc,SM(comp)) && #head_mq == 0
			&& #filterEnabled(
					filterPossible(steps,sc,SM(comp)),
					if(is_signal_event(head(eq)),[head(eq)],[ChangeEvent(get_expression(head(eq)))]),
					if(is_change_event_with_data(head(eq)) || is_signal_event(head(eq)), setMultVars(params(head(eq)),vars), vars)) == 0)
				-> discardEvent(id,head(eq)).StateMachine(
					eq = tail(eq))
		%select multi-step to start executing
		+ (#ms == 0 && #behav == 0 && #head_mq == 0 && exc == EmptyExcFrame && #reset == 0) ->
			(
				StateMachineSelectStep(id,comp,steps,sc,eq,mon,vars)
			)
		%From set of selected transitions pick one to start executing
		+ (#behav == 0 && #head_mq == 0 && exc == EmptyExcFrame) -> sum n:Nat. (n < #ms)
			-> executeStep(id,computeNextState(sc,ms.n)).StateMachine(
				ms = removeSteps(ms,[ms.n]),
				behav = determineBehaviourStep(SM(comp),ms.n,sc),
				sc = computeNextState(sc,ms.n)
			)
		%From behavior that needs to be executed pick an execution option and start executing.
		%Note that for sequential behavior there is only one execution option but a transition may have some parallel behavior
		+ (#behav != 0 && exc == EmptyExcFrame && #head_mq == 0)
			-> sum eo:ExecutionOption.
			(eo in computeExecutionOptions(behav) && #getCodeToExecute(eo) > 0) ->
				StateMachineExecuteCode(
					exc = initializeExcFrame(getCodeToExecute(eo),vars),
					behav = getRemainingBehavior(eo))
		+ (exc != EmptyExcFrame && #head_mq == 0) -> StateMachineExecuteCode()
		%If there are messages waiting to be sent to other components, do that
		+ (#head_mq == 1 ) -> (getValue(head(head_mq)) in possibleValues(id,getVariable(head(head_mq))))
		-> sendComp(CompPortPair(id, getVariable(head(head_mq))),getValue(head(head_mq)))
			.StateMachine(head_mq = if(#mq > 0, [head(mq)], []),
				mq = if(#mq > 0, tail(mq), mq),
				vars = if(is_pulse_pack(getValue(head(head_mq))), resetVariables(vars, paramsPerPulsePort(comp)(getVariable(head(head_mq))), initialValuation(SM(comp))), vars))
		+ (#reset > 0 && #ms == 0 && #behav == 0 && exc == EmptyExcFrame && #head_mq == 0)
			-> resetVariables(id).StateMachine(vars = resetVariables(vars, reset, initialValuation(SM(comp))), reset = []);

	%Executes code in ongoing_execution
	StateMachineExecuteCode(id:CompName, comp:Component, steps:List(Step), sc:StateConfig, eq: List(Event), mon:List(Monitor),
			vars: ValueStorage, ms: List(Step), behav: ComposedBehavior, exc: ExcFrame, mq: List(VarValuePair), head_mq: List(VarValuePair), reset: List(VarName)) =
		executeBehaviour(id).StateMachine(
			%Update mapping of global variables
			vars = resetVariables(globalValuation(executeExcFrameCode(exc)), pulsePorts(comp), initialValuation(SM(comp))),
			%If the function frame has not finished execution we store the function frame in the variable ongoing_execution
			exc = if(!isFinished(executeExcFrameCode(exc)), executeExcFrameCode(exc), EmptyExcFrame),
			%Derive change events from updated variables
			eq = eq ++ deriveChangeEventsMultUpdates(mon,vars,varUpdates(executeExcFrameCode(exc))),
			%Update monitors
			mon = updateMonitors(mon,globalValuation(executeExcFrameCode(exc))),
			%If there was more than one message to send via a port store the remainder in message_output_queue
			mq = %if(#distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp) >= 1 && COMBINE_EB_S,
				%tail(distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp)),
				if(#distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp,vars) > 0, tail(distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp,vars)), []),
			head_mq = if(#distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp,vars) > 0, [head(distillPortUpdates(varUpdates(executeExcFrameCode(exc)),comp,vars))], []))
				%)
				;

	%Selects transition based on event 'ev'
	StateMachineSelectStep(id:CompName, comp:Component, steps:List(Step), sc:StateConfig, eq: List(Event),
			mon:List(Monitor), vars: ValueStorage) =
		sum multi:List(Step). %step may consist of multiple transitions
			(
				multi in multistepPossibilities(
					filterPriority(
						filterEnabled(
							filterPossible(steps, sc, SM(comp)),
							[none,TimeoutEvent] ++ if(#eq > 0 && is_change_event_with_data(head(eq)), [ChangeEvent(get_expression(head(eq)))], [])
								++ if(#eq > 0 && (is_change_event(head(eq)) || is_signal_event(head(eq))), [head(eq)], []),
							if(#eq > 0 && (is_change_event_with_data(head(eq)) || is_signal_event(head(eq))), setMultVars(params(head(eq)),vars), vars))))
			)
			%If the step contains only 1 step we immediately start executing it by computing the next state and the behavior that needs to be executed
			-> (
				(selectMultiStep(id,trigger(head(multi)),target(head(multi)))).StateMachine(
					id, comp, steps,
					if(#multi == 1 && COMBINE_SMS_ES, computeNextState(sc,head(multi)), sc),
					if(#eq > 0 && trigger(head(multi)) == ChangeEvent(get_expression(head(eq))),tail(eq),eq), %if head of event queue was used as trigger remove it from the queue
					mon,
					if(#eq > 0 && ((trigger(head(multi)) == ChangeEvent(get_expression(head(eq))) && is_change_event_with_data(head(eq)))
							|| (trigger(head(multi)) == head(eq) && is_signal_event(head(eq)))),
						setMultVars(params(head(eq)),vars), vars),
					if(#multi == 1 && COMBINE_SMS_ES, [], multi), % ms
					if(#multi == 1 && COMBINE_SMS_ES, determineBehaviourStep(SM(comp),head(multi),sc), []), % behav
					EmptyExcFrame, % exc
          [], % mq
          [], % head_mq
					if(#eq > 0 && ((trigger(head(multi)) == ChangeEvent(get_expression(head(eq))) && is_change_event_with_data(head(eq)))
							|| (trigger(head(multi)) == head(eq) && is_signal_event(head(eq)))),
						getVars(params(head(eq))),[])
				)
			);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Optimization options
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
map
	COMBINE_SMS_ES: Bool; %Combine selectMultiStep and executeStep
	EVENT_QUEUE_BOUND: Nat;
	USE_SYNCHRONOUS_PORTS: Bool;
	ADD_inState_SELFLOOPS: Bool;
	ADD_ALL_inState_SELFLOOPS: Bool;
	ALLOWED_STATES_inState_SELFLOOPS: List(StateName);
	ADD_inEventPool_SELFLOOPS: Bool;
	ADD_ABSTRACT_inEventPool_SELFLOOPS: Bool;
	ADD_ALL_inEventPool_SELFLOOPS: Bool;
	ALLOWED_EVENTS_inEventPool_SELFLOOPS: List(Event);
	RESET_VARIABLES_INITIAL: Bool;
	ADD_varVal_SELFLOOPS: Bool;
  ADD_ALL_varVal_SELFLOOPS: Bool;
	ALLOWED_VARS_varVal_SELFLOOPS: List(VarName);
	USE_PULSE_PACKS: Bool;
	USE_ENV_RESTRICTION: Bool;
	resetVariables: ValueStorage#List(VarName)#ValueStorage -> ValueStorage;
var
	c: CompName;
	i: Instruction; i_list: List(Instruction);
	v: VarName;
	tr: Transition; trs: List(Transition);
	s: StateName; s_list: List(StateName);
	f: FunctionName; f_list: List(FunctionName);
	written, read: FSet(VarName);
	vs, vs_init: ValueStorage;
	vl: List(VarName);
eqn
	resetVariables(vs, [], vs_init) = vs;
	resetVariables(vs, v |> vl, vs_init) = resetVariables(setValue(vs,v,getValue(vs_init,v)),vl,vs_init);

%Elements needed to make spec parsable on its own
% sort
%  	Custom_Value  = struct string_dummy;
%  	VarName = struct finished1;
%  	FunctionName = struct getResult;
%  	StateName = struct initial0 | root;
% 	CompName = struct main | worker1 | worker2;
% 	ValueStorage = struct ValueStorage_BEQ_pe51(Value, Value);
% map
% 	getFunctionParams: FunctionName -> List(VarName);
% 	getFunctionBodies: FunctionName -> Instructions;
% 	compDefs: CompName -> Component;
% 	SMDefs: CompName -> StateMachine;
% 	stateIndex: StateName -> Nat;
% 	getValue: ValueStorage#VarName -> Value;
% 	setValue: ValueStorage#VarName#Value -> ValueStorage;
% 	getConnectedDataParameterPort: CompName -> VarName -> VarName;
% 	possibleValues: CompName#VarName -> List(Value);
%  init
%   delta;
